

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gastrodon &mdash; gastrodon 0.9.3 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="gastrodon 0.9.3 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> gastrodon
          

          
          </a>

          
            
            
              <div class="version">
                0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">gastrodon</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>gastrodon</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for gastrodon</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Gastrodon module header</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">lru_cache</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">stdout</span><span class="p">,</span><span class="n">_getframe</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">FunctionType</span><span class="p">,</span><span class="n">LambdaType</span><span class="p">,</span><span class="n">GeneratorType</span><span class="p">,</span><span class="n">CoroutineType</span><span class="p">,</span><span class="n">FrameType</span><span class="p">,</span><span class="n">CodeType</span><span class="p">,</span><span class="n">MethodType</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">BuiltinFunctionType</span><span class="p">,</span><span class="n">BuiltinMethodType</span><span class="p">,</span><span class="n">DynamicClassAttribute</span><span class="p">,</span><span class="n">ModuleType</span><span class="p">,</span><span class="n">AsyncGeneratorType</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Dict</span><span class="p">,</span><span class="n">GenericMeta</span><span class="p">,</span><span class="n">Match</span>
<span class="kn">from</span> <span class="nn">urllib.error</span> <span class="k">import</span> <span class="n">HTTPError</span>
<span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urlparse</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="k">import</span> <span class="n">display_png</span>
<span class="kn">from</span> <span class="nn">SPARQLWrapper</span> <span class="k">import</span> <span class="n">SPARQLWrapper</span><span class="p">,</span> <span class="n">JSON</span>
<span class="kn">from</span> <span class="nn">pyparsing</span> <span class="k">import</span> <span class="n">ParseResults</span><span class="p">,</span> <span class="n">ParseException</span>
<span class="kn">from</span> <span class="nn">rdflib</span> <span class="k">import</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">URIRef</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">BNode</span><span class="p">,</span> <span class="n">RDF</span>
<span class="kn">from</span> <span class="nn">rdflib.namespace</span> <span class="k">import</span> <span class="n">NamespaceManager</span>
<span class="kn">from</span> <span class="nn">rdflib.plugins.serializers.turtle</span> <span class="k">import</span> <span class="n">TurtleSerializer</span>
<span class="kn">from</span> <span class="nn">rdflib.plugins.sparql.processor</span> <span class="k">import</span> <span class="n">SPARQLResult</span>
<span class="kn">from</span> <span class="nn">rdflib.plugins.sparql.parser</span> <span class="k">import</span> <span class="n">parseQuery</span><span class="p">,</span><span class="n">parseUpdate</span>

<span class="kn">from</span> <span class="nn">rdflib.store</span> <span class="k">import</span> <span class="n">Store</span>
<span class="kn">from</span> <span class="nn">rdflib.term</span> <span class="k">import</span> <span class="n">Identifier</span><span class="p">,</span> <span class="n">_castPythonToLiteral</span><span class="p">,</span> <span class="n">Variable</span>

<span class="c1">#</span>
<span class="c1"># types that could not reasonably be expected to be serialized automatically to RDF terms in a SPARQL query.</span>
<span class="c1">#</span>

<span class="n">_cannot_substitute</span><span class="o">=</span><span class="p">{</span>
    <span class="n">FunctionType</span><span class="p">,</span><span class="n">LambdaType</span><span class="p">,</span><span class="n">GeneratorType</span><span class="p">,</span><span class="n">CoroutineType</span><span class="p">,</span><span class="n">FrameType</span><span class="p">,</span><span class="n">CodeType</span><span class="p">,</span><span class="n">MethodType</span><span class="p">,</span>
    <span class="n">BuiltinFunctionType</span><span class="p">,</span><span class="n">BuiltinMethodType</span><span class="p">,</span><span class="n">DynamicClassAttribute</span><span class="p">,</span><span class="n">ModuleType</span><span class="p">,</span><span class="n">AsyncGeneratorType</span><span class="p">,</span>
    <span class="n">ABCMeta</span><span class="p">,</span><span class="n">GenericMeta</span><span class="p">,</span><span class="nb">type</span>
<span class="p">}</span>

<span class="n">_pncb_regex</span><span class="o">=</span><span class="s1">&#39;_A-Za-z</span><span class="se">\u00C0</span><span class="s1">-</span><span class="se">\u00D6\u00D8</span><span class="s1">-</span><span class="se">\u00F6\u00F8</span><span class="s1">-</span><span class="se">\u02FF\u0370</span><span class="s1">-</span><span class="se">\u037D\u037F</span><span class="s1">-</span><span class="se">\u1FFF\u200C</span><span class="s1">-</span><span class="se">\u200D\u2070</span><span class="s1">-</span><span class="se">\u218F\u2C00</span><span class="s1">-</span><span class="se">\u2FEF\u3001</span><span class="s1">-</span><span class="se">\uD7FF\uF900</span><span class="s1">-</span><span class="se">\uFDCF\uFDF0</span><span class="s1">-</span><span class="se">\uFFFD\U00010000</span><span class="s1">-</span><span class="se">\U000EFFFF</span><span class="s1">&#39;</span>
<span class="n">_pncu_regex</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">_pncb_regex</span>
<span class="n">_pnc_regex</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">-0-9</span><span class="se">\u00B7\u0300</span><span class="s1">-</span><span class="se">\u036F\u203F</span><span class="s1">-</span><span class="se">\u2040</span><span class="s1">&#39;</span><span class="o">+</span><span class="n">_pncb_regex</span>
<span class="n">_var_regex</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;[?$]([</span><span class="si">%s</span><span class="s1">0-9][</span><span class="si">%s</span><span class="s1">0-9</span><span class="se">\u00B7\u0300</span><span class="s1">-</span><span class="se">\u036F\u203F</span><span class="s1">-</span><span class="se">\u2040</span><span class="s1">]*)&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">_pncu_regex</span><span class="p">,)</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span>
<span class="c1"># a modified version of the PN_LOCAL regex from the SPARQL 1.1 specification with the percentage and colon</span>
<span class="c1"># characters removed,  as this is used to tell if we can tell if a full URI can be safely converted to a QName</span>
<span class="c1"># or not</span>
<span class="n">_valid_tail_regex</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">0-9]([</span><span class="si">%s</span><span class="s2">.]*[</span><span class="si">%s</span><span class="s2">])?&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_pncu_regex</span><span class="p">,</span><span class="n">_pnc_regex</span><span class="p">,</span><span class="n">_pnc_regex</span><span class="p">))</span>

<span class="c1"># % (</span>
<span class="c1">#     PN_CHARS_U_re)</span>

<div class="viewcode-block" id="GastrodonURI"><a class="viewcode-back" href="../api.html#gastrodon.GastrodonURI">[docs]</a><span class="k">class</span> <span class="nc">GastrodonURI</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class is used to wrap a URI that is passed from Gastrodon to Pandas and back again.</span>

<span class="sd">        `GastrodonURI` subclasses `str`</span>

<span class="sd">        It keeps track of</span>
<span class="sd">        both a shortened URI (if a namespace is given) and the full URI,  so we can roundtrip this object out of the</span>
<span class="sd">        table and back into a SPARQL query without a chance of a short name being mistaken for an ordinary string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">short</span><span class="p">,</span><span class="n">uri_ref</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">short</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">short</span><span class="p">,</span><span class="n">uri_ref</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uri_ref</span><span class="o">=</span><span class="n">uri_ref</span>

<div class="viewcode-block" id="GastrodonURI.to_uri_ref"><a class="viewcode-back" href="../api.html#gastrodon.GastrodonURI.to_uri_ref">[docs]</a>    <span class="k">def</span> <span class="nf">to_uri_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">URIRef</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: an RDFLib :class:`rdflib.URIRef`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">uri_ref</span></div></div>

<div class="viewcode-block" id="QName"><a class="viewcode-back" href="../api.html#gastrodon.QName">[docs]</a><span class="k">class</span> <span class="nc">QName</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class represents a qualified name.</span>

<span class="sd">        This class makes it easy to write qualified names,  without ambiguity,  in Python variables that</span>
<span class="sd">        later get substituted into SPARQL variables.  If</span>

<span class="sd">        ``@prefix bibo: &lt;http://purl.org/ontology/bibo/&gt;``</span>

<span class="sd">        is declared for an Endpoint,  and one writes in Python</span>

<span class="sd">        ``objectType=QName(&quot;bibo:AcademicPaper&quot;)``</span>

<span class="sd">        then the SPARQL variable ``?_objectType`` will be replaced with a URI Referemce</span>

<span class="sd">        ``&lt;http://purl.org/ontology/bibo/AcademicPaper&gt;``</span>

<span class="sd">        for queries inside the scope in which `_objectType` is local.  Note that if you simply wrote</span>

<span class="sd">        ``objectType=&quot;bibo:AcademicPaper&quot;``</span>

<span class="sd">        the value substituted in SPARQL would be just the string</span>

<span class="sd">        ``&quot;bibo:AcademicPaper&quot;``</span>

<span class="sd">        If one wants to write a URI Reference as a full URI,  simply use the `URIRef` class from rdflib,  ex.</span>

<span class="sd">        ``objectType=URIRef(&quot;http://purl.org/ontology/bibo/AcademicPaper&quot;)``</span>


<span class="sd">        :param name: qualified name of the form &#39;prefix:localname&#39;,  such as &#39;rdf:type&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">name</span>

<div class="viewcode-block" id="QName.toURIRef"><a class="viewcode-back" href="../api.html#gastrodon.QName.toURIRef">[docs]</a>    <span class="k">def</span> <span class="nf">toURIRef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">manager</span><span class="p">:</span><span class="n">NamespaceManager</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">URIRef</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert to URI Reference</span>

<span class="sd">        :param manager: :class:`rdflib.namespace.NamespaceManager` used to resolve namespace</span>
<span class="sd">        :return: A :class:`rdflib.URIRef`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;:&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">head</span><span class="p">,</span><span class="n">tail</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span><span class="n">ns</span> <span class="ow">in</span> <span class="n">manager</span><span class="o">.</span><span class="n">namespaces</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">prefix</span><span class="o">==</span><span class="n">head</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ns</span><span class="o">+</span><span class="n">tail</span>
        <span class="k">return</span> <span class="n">URIRef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div></div>

<span class="n">_last_exception</span><span class="o">=</span><span class="p">[]</span>

<div class="viewcode-block" id="GastrodonException"><a class="viewcode-back" href="../api.html#gastrodon.GastrodonException">[docs]</a><span class="k">class</span> <span class="nc">GastrodonException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gastrodon-specific exception.  The primary features of this is that it defines the method</span>
<span class="sd">        `_render_traceback_` which controls the way the exception is drawn in IPython.</span>

<span class="sd">        :param args: positional arguments for `Exception`</span>
<span class="sd">        :param kwargs: keyword arguments for `Exception`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">:</span><span class="n">Dict</span><span class="o">=</span><span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;lines&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;lines&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">_render_traceback_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;lines&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="GastrodonException.throw"><a class="viewcode-back" href="../api.html#gastrodon.GastrodonException.throw">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">throw</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Throws a new :class:`GastrodonException` with the following positional and keyword arguments while</span>
<span class="sd">        suppressing the context of the :class:`Exception` to enable short error messages in Jupyter</span>

<span class="sd">        :param args: positional arguments for Exception</span>
<span class="sd">        :param kwargs: keyword arguments for Exception</span>
<span class="sd">        :return: does not return</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">GastrodonException</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">None</span></div></div>

<div class="viewcode-block" id="Endpoint"><a class="viewcode-back" href="../api.html#gastrodon.Endpoint">[docs]</a><span class="k">class</span> <span class="nc">Endpoint</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An Endpoint is something which can answer SPARQL queries.    `Endpoint`</span>
<span class="sd">        is an abstract base class and cannot be instantiated on its own.</span>
<span class="sd">        Current implementations include</span>
<span class="sd">        a :class:`RemoteEndpoint` via the SPARQL protocol or a :class:`LocalEndpoint` provided by rdflib.</span>

<span class="sd">        :param prefixes: Graph object with attached namespace mappings to be applied to the new :class:`Endpoint`</span>
<span class="sd">        :param base_uri: base URI to control the base namespace of the :class:`Endpoint` as we see it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qname_regex</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;(?&lt;![A-Za-z&lt;])([A-Za-z_][A-Za-z_0-9.-]*):&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prefixes</span><span class="p">:</span><span class="n">Graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">base_uri</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefixes</span><span class="o">=</span><span class="n">prefixes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_uri</span><span class="o">=</span><span class="n">base_uri</span>
        <span class="k">if</span> <span class="n">prefixes</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_namespaces</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">}</span> <span class="k">else</span> <span class="n">y</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">prefixes</span><span class="o">.</span><span class="n">namespaces</span><span class="p">()]))</span>

<div class="viewcode-block" id="Endpoint.namespaces"><a class="viewcode-back" href="../api.html#gastrodon.Endpoint.namespaces">[docs]</a>    <span class="k">def</span> <span class="nf">namespaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display prefix to namespace mapping.</span>

<span class="sd">        Produces a Pandas `DataFrame` that looks something like this</span>

<span class="sd">        ======  ==============================</span>
<span class="sd">        prefix  namespace</span>
<span class="sd">        ======  ==============================</span>
<span class="sd">        bibo    ``http://purl.org/ontology/bibo/``</span>
<span class="sd">        cc      ``http://creativecommons.org/ns#``</span>
<span class="sd">        dbo     ``http://dbpedia.org/ontology/``</span>
<span class="sd">        ...     ...</span>
<span class="sd">        ======  ==============================</span>

<span class="sd">        where `prefix` is the index of the dataframe so you can look up a namespace like</span>

<span class="sd">        ``endpoint.namespaces().at[&#39;bibo&#39;,&#39;namespace&#39;]``</span>

<span class="sd">        :return: :class:`pandas.DataFrame` describing the prefix to namespace mapping used for this endpoint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefixes</span><span class="o">.</span><span class="n">namespaces</span><span class="p">()]</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefixes</span><span class="o">.</span><span class="n">namespaces</span><span class="p">()]</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;namespace&quot;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span>
        <span class="n">frame</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;prefix&quot;</span>
        <span class="k">return</span> <span class="n">frame</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span></div>

<div class="viewcode-block" id="Endpoint.is_ok_qname"><a class="viewcode-back" href="../api.html#gastrodon.Endpoint.is_ok_qname">[docs]</a>    <span class="k">def</span> <span class="nf">is_ok_qname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Many :class:`URIRef`\s can be resolved to a namespace and written as a short name (QName),  except when special</span>
<span class="sd">        characters such as parenthesis and colon are in the localpart of the domain.  In that case,  the :class:`URIRef`</span>
<span class="sd">        should be rendered in RDF as an absolute URI (ex. ``&lt;http://example.com/&gt;``).</span>

<span class="sd">        :param url: a URIRef or a str for a URL</span>
<span class="sd">        :return: true if the URIRef can be safely resolved to a namespace in short form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">pos</span><span class="p">:]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_valid_tail_regex</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">suffix</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespaces</span></div>

<div class="viewcode-block" id="Endpoint.ns_part"><a class="viewcode-back" href="../api.html#gastrodon.Endpoint.ns_part">[docs]</a>    <span class="k">def</span> <span class="nf">ns_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a URI like</span>

<span class="sd">        ``http://purl.org/ontology/bibo/AcademicArticle``</span>

<span class="sd">        return the namespace part of the URI,  which would be</span>

<span class="sd">        ``http://purl.org/ontology/bibo/``</span>

<span class="sd">        This is based on the syntax of the URI,  not the declared prefixes associated</span>
<span class="sd">        with this URI.</span>

<span class="sd">        :param url: URIRef or string URL</span>
<span class="sd">        :return: namespace part of URL as string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[:</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Endpoint.local_part"><a class="viewcode-back" href="../api.html#gastrodon.Endpoint.local_part">[docs]</a>    <span class="k">def</span> <span class="nf">local_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a URI like</span>

<span class="sd">        ``http://purl.org/ontology/bibo/AcademicArticle``</span>

<span class="sd">        return the localname part of the URI,  which would be</span>

<span class="sd">        ``AcademicArticle``</span>

<span class="sd">        This is based on the syntax of the URI,  not the declared prefixes associated</span>
<span class="sd">        with this URI.</span>

<span class="sd">        :param url: URIRef or string URL</span>
<span class="sd">        :return: localname part of URL as string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span></div>

<div class="viewcode-block" id="Endpoint.to_python"><a class="viewcode-back" href="../api.html#gastrodon.Endpoint.to_python">[docs]</a>    <span class="k">def</span> <span class="nf">to_python</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a simple rdflib `term` into a idiomatic Python object.</span>

<span class="sd">        A simple rdflib term is entirely self-contained;  either a literal value or a signifier (a Resource) floating</span>
<span class="sd">        in space,  without consideration of other facts in the graph.</span>

<span class="sd">        For RDF literals and blank nodes,  behavior is exactly the same as the `toPython` method,  which this encloses.</span>
<span class="sd">        URIReferences are wrapped in `GastrodonURI` objects which look like short names (QNames) inside Jupyter and Pandas,</span>
<span class="sd">        but remember the full URI if they are later used with Gastrodon.</span>

<span class="sd">        This is a method of an `Endpoint` as opposed to a static method or method of a `term` wrapper because the</span>
<span class="sd">        exact resolution to a QName is relative to the namespaces defined for that `Endpoint`.</span>

<span class="sd">        :param term: an RDFLib Node object</span>
<span class="sd">        :return: a Plain Ordinary Python Object except for URI References which are returned as GastrodonURI</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">term</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">URIRef</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefixes</span> <span class="o">!=</span><span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;/&quot;</span> <span class="ow">in</span> <span class="n">term</span><span class="o">.</span><span class="n">toPython</span><span class="p">()</span> <span class="ow">or</span> <span class="nb">str</span><span class="p">(</span><span class="n">term</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;urn:&#39;</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_uri</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">term</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_uri</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">GastrodonURI</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span> <span class="o">+</span> <span class="n">term</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_uri</span><span class="p">):]</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ok_qname</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">GastrodonURI</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">short_name</span><span class="p">(</span><span class="n">term</span><span class="p">),</span> <span class="n">term</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">pass</span>
            <span class="k">return</span> <span class="n">term</span>

        <span class="k">return</span> <span class="n">term</span><span class="o">.</span><span class="n">toPython</span><span class="p">()</span></div>

<div class="viewcode-block" id="Endpoint.short_name"><a class="viewcode-back" href="../api.html#gastrodon.Endpoint.short_name">[docs]</a>    <span class="k">def</span> <span class="nf">short_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">term</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assuming we&#39;ve made the following namespace declaration on this endpoint,</span>

<span class="sd">        ``@prefix bibo: &lt;http://purl.org/ontology/bibo/&gt;``</span>

<span class="sd">        and given a URI like</span>

<span class="sd">        ``http://purl.org/ontology/bibo/AcademicArticle``</span>

<span class="sd">        this returns</span>

<span class="sd">        ``bibo:AcademicArticle``</span>

<span class="sd">        which can be used as a QName relative to the Endpoint.</span>

<span class="sd">        :param term: URIRef which can be expressed with a QName</span>
<span class="sd">        :return: the QName,  as a string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefixes</span><span class="o">.</span><span class="n">compute_qname</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">prefix</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_process_namespaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparql</span><span class="p">,</span> <span class="n">parseFn</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefixes</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sparql</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepend_namespaces</span><span class="p">(</span><span class="n">sparql</span><span class="p">,</span> <span class="n">parseFn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sparql</span>

    <span class="k">def</span> <span class="nf">_candidate_prefixes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparql</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qname_regex</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">sparql</span><span class="p">)}</span>

    <span class="k">def</span> <span class="nf">_prepend_namespaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparql</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">parseFn</span><span class="p">):</span>

        <span class="c1"># extract prefixes and base uri from the query so that we won&#39;t try to</span>
        <span class="c1"># overwrite them</span>

        <span class="n">parsed</span> <span class="o">=</span> <span class="n">parseFn</span><span class="p">(</span><span class="n">sparql</span><span class="p">)</span>
        <span class="p">(</span><span class="n">query_base</span><span class="p">,</span><span class="n">query_ns</span><span class="p">)</span><span class="o">=</span><span class="n">_extract_decl</span><span class="p">(</span><span class="n">parsed</span><span class="p">,</span><span class="n">parseFn</span><span class="p">)</span>

        <span class="n">candidates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidate_prefixes</span><span class="p">(</span><span class="n">sparql</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">q_prefix</span><span class="p">,</span><span class="n">q_uri</span><span class="p">)</span> <span class="ow">in</span> <span class="n">query_ns</span><span class="o">.</span><span class="n">namespaces</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">q_prefix</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="n">candidates</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">q_prefix</span><span class="p">)</span>

        <span class="n">ns_section</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_uri</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">query_base</span><span class="p">:</span>
            <span class="n">ns_section</span> <span class="o">+=</span> <span class="s2">&quot;base &lt;</span><span class="si">%s</span><span class="s2">&gt;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_uri</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefixes</span><span class="o">.</span><span class="n">namespaces</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="n">ns_section</span> <span class="o">+=</span> <span class="s2">&quot;prefix </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">value</span><span class="o">.</span><span class="n">n3</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">ns_section</span><span class="o">+</span><span class="n">sparql</span>

    <span class="k">def</span> <span class="nf">_substitute_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparql</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span><span class="n">Dict</span><span class="p">,</span> <span class="n">prefixes</span><span class="p">:</span><span class="n">NamespaceManager</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">substitute_one</span><span class="p">(</span><span class="n">m</span><span class="p">:</span><span class="n">Match</span><span class="p">):</span>
            <span class="n">name</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_rdf</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">prefixes</span><span class="p">)</span><span class="o">.</span><span class="n">n3</span><span class="p">()</span>

        <span class="n">sparql</span> <span class="o">=</span> <span class="n">_var_regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">substitute_one</span><span class="p">,</span><span class="n">sparql</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sparql</span>

    <span class="k">def</span> <span class="nf">_to_rdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">prefixes</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">QName</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">toURIRef</span><span class="p">(</span><span class="n">prefixes</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">GastrodonURI</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to_uri_ref</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">_toRDF</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="c1"># virtuoso-specific hack for bnodes</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">BNode</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bnode_to_sparql</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_bnode_to_sparql</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bnode</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bnode</span>

    <span class="k">def</span> <span class="nf">_normalize_column_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">column</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">==</span><span class="kc">None</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">,</span><span class="n">column</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">column</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">column</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">column</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">column</span>

    <span class="k">def</span> <span class="nf">_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span><span class="n">SPARQLResult</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">columnNames</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">vars</span><span class="p">]</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">columnNames</span><span class="p">:</span>
            <span class="n">column</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bindings</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">bindings</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">vars</span><span class="p">:</span>
                <span class="n">column</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">variable</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_python</span><span class="p">(</span><span class="n">bindings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">variable</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">column</span><span class="p">:</span>
            <span class="n">column</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_column_type</span><span class="p">(</span><span class="n">column</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

<div class="viewcode-block" id="Endpoint.decollect"><a class="viewcode-back" href="../api.html#gastrodon.Endpoint.decollect">[docs]</a>    <span class="k">def</span> <span class="nf">decollect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        :param node: a URIRef pointing to an rdf:Seq, rdf:Bag, or rdf:Alt</span>
<span class="sd">        :return: a Python List, Counter, or Set of POPOs</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">survey</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">select_raw</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            SELECT ?type {</span>
<span class="s2">                VALUES (?type) { (rdf:Seq) (rdf:Bag) (rdf:Alt)}</span>
<span class="s2">                ?s a ?type</span>
<span class="s2">            } </span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span><span class="n">bindings</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">node</span><span class="p">))</span>

        <span class="n">types</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">survey</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">RDF</span><span class="o">.</span><span class="n">Bag</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decollect_Bag</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decollect_Seq</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_decollect_Seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">select_raw</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            SELECT ?index ?item {</span>
<span class="s2">                ?s ?predicate ?item</span>
<span class="s2">                FILTER(STRSTARTS(STR(?predicate),&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#_&quot;))</span>
<span class="s2">                BIND(xsd:integer(SUBSTR(STR(?predicate),45)) AS ?index)</span>
<span class="s2">            } ORDER BY ?index</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span><span class="n">bindings</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">node</span><span class="p">))</span>
        <span class="n">output</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_python</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;item&quot;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">output</span>


    <span class="k">def</span> <span class="nf">_decollect_Bag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">select_raw</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            SELECT ?item (COUNT(*) AS ?count) {</span>
<span class="s2">                ?s ?predicate ?item</span>
<span class="s2">                FILTER(STRSTARTS(STR(?predicate),&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#_&quot;))</span>
<span class="s2">                BIND(xsd:integer(SUBSTR(STR(?predicate),45)) AS ?index)</span>
<span class="s2">            } GROUP BY ?item </span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span><span class="n">bindings</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">node</span><span class="p">))</span>
        <span class="n">output</span><span class="o">=</span><span class="n">Counter</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">to_python</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;item&quot;</span><span class="p">])]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">to_python</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">output</span>


    <span class="k">def</span> <span class="nf">_decollect_Seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">select_raw</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            SELECT ?index ?item {</span>
<span class="s2">                ?s ?predicate ?item</span>
<span class="s2">                FILTER(STRSTARTS(STR(?predicate),&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#_&quot;))</span>
<span class="s2">                BIND(xsd:integer(SUBSTR(STR(?predicate),45)) AS ?index)</span>
<span class="s2">            } ORDER BY ?index</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span><span class="n">bindings</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">node</span><span class="p">))</span>
        <span class="n">output</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_python</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;item&quot;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">result</span><span class="p">):</span>
        <span class="n">columnNames</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">vars</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columnNames</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Currently can only create a set from a single column result&quot;</span><span class="p">)</span>
        <span class="n">that</span><span class="o">=</span><span class="n">columnNames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">output</span><span class="o">=</span><span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">bindings</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">bindings</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bindings</span><span class="p">[</span><span class="n">that</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparql</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SPARQLResult</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparql</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparql</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="Endpoint.select"><a class="viewcode-back" href="../api.html#gastrodon.Endpoint.select">[docs]</a>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sparql</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a SPARQL SELECT query against the endpoint.  To make interactive</span>
<span class="sd">        queries easy in the Jupyter environment,  any variable with a name beginning with</span>
<span class="sd">        an underscore (eg. ?_var or @_var)</span>
<span class="sd">        in the SPARQL query will be replaced with an RDF serialized version of the</span>
<span class="sd">        variable (eg. var) in the python stack frame of the caller.</span>

<span class="sd">        If you call this in a Jupyter notebook,  it sees all variables that are accessible</span>
<span class="sd">        from the cells in the notebook.  If you call it inside a function definition,  it</span>
<span class="sd">        sees variables local to that definition.</span>

<span class="sd">        :param sparql: SPARQL SELECT query</span>
<span class="sd">        :param kwargs: any keyword arguments are implementation-dependent</span>
<span class="sd">        :return: SELECT result as a Pandas DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_raw</span><span class="p">(</span><span class="n">sparql</span><span class="p">,</span><span class="n">_user_frame</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataframe</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">columnNames</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">vars</span><span class="p">}</span>
        <span class="n">parsed</span><span class="o">=</span><span class="n">_parseQuery</span><span class="p">(</span><span class="n">sparql</span><span class="p">)</span>
        <span class="n">group_variables</span><span class="o">=</span><span class="n">_extract_group_by</span><span class="p">(</span><span class="n">parsed</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">group_variables</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">columnNames</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">group_variables</span><span class="p">]):</span>
            <span class="n">frame</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">group_variables</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">frame</span></div>

    <span class="k">def</span> <span class="nf">select_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sparql</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="n">_user_frame</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SPARQLResult</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a SPARQL SELECT query as would the select method,  but do not</span>
<span class="sd">        convert result to a DataFrame,  instead return the original</span>
<span class="sd">        SPARQLResult</span>

<span class="sd">        :param sparql: SPARQL SELECT query</span>
<span class="sd">        :param kwargs: any keyword arguments are implementation-dependent</span>
<span class="sd">        :return: result as a SPARQLResult</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exec_raw</span><span class="p">(</span><span class="n">sparql</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_select</span><span class="p">,</span><span class="n">_user_frame</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Endpoint.construct"><a class="viewcode-back" href="../api.html#gastrodon.Endpoint.construct">[docs]</a>    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sparql</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="n">_user_frame</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a SPARQL CONSTRUCT query,  making the same substitutions as</span>
<span class="sd">        the select method.  Returns a Graph</span>

<span class="sd">        :param sparql: SPARQL SELECT query</span>
<span class="sd">        :param kwargs: any keyword arguments are implementation-dependent</span>
<span class="sd">        :return: result as a Graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exec_raw</span><span class="p">(</span><span class="n">sparql</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct</span><span class="p">,</span><span class="n">_user_frame</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_exec_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sparql</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="n">operation</span><span class="p">,</span><span class="n">_user_frame</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sparql</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_namespaces</span><span class="p">(</span><span class="n">sparql</span><span class="p">,</span> <span class="n">_parseQuery</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ParseException</span> <span class="k">as</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_error_header</span><span class="p">()</span>
            <span class="n">lines</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="s2">&quot;Failure parsing SPARQL query supplied by caller;  this is either a user error&quot;</span><span class="p">,</span>
                <span class="s2">&quot;or an error in a function that generated this query.  Query text follows:&quot;</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span>
            <span class="p">]</span>
            <span class="n">error_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mark_query</span><span class="p">(</span><span class="n">sparql</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">+=</span> <span class="n">error_lines</span>
            <span class="n">GastrodonException</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="s2">&quot;Error parsing SPARQL query&quot;</span><span class="p">,</span><span class="n">lines</span><span class="o">=</span><span class="n">lines</span><span class="p">,</span><span class="n">inner_exception</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;bindings&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">bindings</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;bindings&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bindings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_frame</span><span class="p">(</span><span class="n">_getframe</span><span class="p">(</span><span class="n">_user_frame</span><span class="p">))</span>

        <span class="n">sparql</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitute_arguments</span><span class="p">(</span><span class="n">sparql</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefixes</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;_inject_post_substitute_fault&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sparql</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;_inject_post_substitute_fault&quot;</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">operation</span><span class="p">(</span><span class="n">sparql</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ParseException</span> <span class="k">as</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_error_header</span><span class="p">()</span>
            <span class="n">lines</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="s2">&quot;Failure parsing SPARQL query after argument substitution.  This is almost certainly an error inside&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Gastrodon.  Substituted query text follows:&quot;</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span>
            <span class="p">]</span>
            <span class="n">error_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mark_query</span><span class="p">(</span><span class="n">sparql</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">+=</span> <span class="n">error_lines</span>
            <span class="n">GastrodonException</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="s2">&quot;Error parsing substituted SPARQL query&quot;</span><span class="p">,</span><span class="n">lines</span><span class="o">=</span><span class="n">lines</span><span class="p">,</span><span class="n">inner_exception</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">HTTPError</span> <span class="k">as</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_error_header</span><span class="p">()</span>
            <span class="n">url_parts</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">geturl</span><span class="p">())</span>
            <span class="n">lines</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="s2">&quot;HTTP Error doing Remote SPARQL query to endpoint at&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span>
            <span class="p">]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">GastrodonException</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="s2">&quot;HTTP Error doing Remote SPARQL query&quot;</span><span class="p">,</span><span class="n">lines</span><span class="o">=</span><span class="n">lines</span><span class="p">,</span><span class="n">inner_exception</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_mark_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparql</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">error_lines</span> <span class="o">=</span> <span class="n">sparql</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">error_lines</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;^&quot;</span><span class="p">)</span>
        <span class="n">error_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Error at line </span><span class="si">%d</span><span class="s2"> and column </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">col</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">error_lines</span>

    <span class="k">def</span> <span class="nf">_error_header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="s2">&quot;*** ERROR ***&quot;</span><span class="p">,</span>
            <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">]</span>

<div class="viewcode-block" id="Endpoint.update"><a class="viewcode-back" href="../api.html#gastrodon.Endpoint.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sparql</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="n">_user_frame</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a SPARQL update statement with the same substitutions as the select method</span>

<span class="sd">        :param sparql: SPARQL update query,  as a str</span>
<span class="sd">        :param _user_frame: Number of stack frames to look back to find variables;  defaults to 1,  which gets variables from the caller, 2 gets them from the caller of the caller and so forth</span>
<span class="sd">        :param kwargs: dependent on implementation</span>
<span class="sd">        :return: nothing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sparql</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_namespaces</span><span class="p">(</span><span class="n">sparql</span><span class="p">,</span> <span class="n">_parseUpdate</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ParseException</span> <span class="k">as</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_error_header</span><span class="p">()</span>
            <span class="n">lines</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="s2">&quot;Failure parsing SPARQL update statement supplied by caller;  this is either a user error or &quot;</span><span class="p">,</span>
                <span class="s2">&quot;an error in a function that generated this query.  Query text follows:&quot;</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span>
            <span class="p">]</span>
            <span class="n">error_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mark_query</span><span class="p">(</span><span class="n">sparql</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">+=</span> <span class="n">error_lines</span>
            <span class="n">GastrodonException</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="s2">&quot;Error parsing SPARQL query&quot;</span><span class="p">,</span> <span class="n">lines</span><span class="o">=</span><span class="n">lines</span><span class="p">,</span> <span class="n">inner_exception</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;bindings&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">bindings</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;bindings&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bindings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_frame</span><span class="p">(</span><span class="n">_getframe</span><span class="p">(</span><span class="n">_user_frame</span><span class="p">))</span>
        <span class="n">sparql</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitute_arguments</span><span class="p">(</span><span class="n">sparql</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefixes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">sparql</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_filter_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">that</span><span class="p">:</span><span class="n">FrameType</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;_&quot;</span><span class="o">+</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
                <span class="ow">in</span> <span class="n">that</span><span class="o">.</span><span class="n">f_locals</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_cannot_substitute</span>
                   <span class="ow">and</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="RemoteEndpoint"><a class="viewcode-back" href="../api.html#gastrodon.RemoteEndpoint">[docs]</a><span class="k">class</span> <span class="nc">RemoteEndpoint</span><span class="p">(</span><span class="n">Endpoint</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Represents a SPARQL endpoint available under the SPARQL Protocol.</span>

<span class="sd">        :param url: String URL for the SPARQL endpoint</span>
<span class="sd">        :param prefixes: Graph containing prefix declarations for this endpoint</span>
<span class="sd">        :param http_auth: http authentication method (eg. &quot;BASIC&quot;, &quot;DIGEST&quot;)</span>
<span class="sd">        :param default_graph: str URL for default graph</span>
<span class="sd">        :param base_uri: str for base URI for purposes of name resolution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">url</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="n">prefixes</span><span class="p">:</span><span class="n">Graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">user</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">passwd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">http_auth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">default_graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">base_uri</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">prefixes</span><span class="p">,</span><span class="n">base_uri</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="o">=</span><span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="o">=</span><span class="n">user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">passwd</span><span class="o">=</span><span class="n">passwd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">http_auth</span><span class="o">=</span><span class="n">http_auth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_graph</span><span class="o">=</span><span class="n">default_graph</span>

    <span class="k">def</span> <span class="nf">_jsonToNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jsdata</span><span class="p">):</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="n">jsdata</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">jsdata</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;uri&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;typed-literal&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="n">jsdata</span><span class="p">[</span><span class="s2">&quot;datatype&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;bnode&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BNode</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_jsonToPython</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jsdata</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_python</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jsonToNode</span><span class="p">(</span><span class="n">jsdata</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_bnode_to_sparql</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bnode</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">bnode</span><span class="o">.</span><span class="n">to_python</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparql</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">that</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapper</span><span class="p">()</span>
        <span class="n">that</span><span class="o">.</span><span class="n">setQuery</span><span class="p">(</span><span class="n">sparql</span><span class="p">)</span>
        <span class="n">that</span><span class="o">.</span><span class="n">setReturnFormat</span><span class="p">(</span><span class="n">JSON</span><span class="p">)</span>
        <span class="n">that</span><span class="o">.</span><span class="n">setMethod</span><span class="p">(</span><span class="s2">&quot;POST&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">that</span><span class="o">.</span><span class="n">queryAndConvert</span><span class="p">()</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sparql_wrapper</span> <span class="o">=</span> <span class="n">SPARQLWrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="n">sparql_wrapper</span><span class="o">.</span><span class="n">user</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">user</span>
        <span class="n">sparql_wrapper</span><span class="o">.</span><span class="n">passwd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">passwd</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_graph</span><span class="p">:</span>
            <span class="n">sparql_wrapper</span><span class="o">.</span><span class="n">addDefaultGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default_graph</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">http_auth</span><span class="p">:</span>
            <span class="n">sparql_wrapper</span><span class="o">.</span><span class="n">setHTTPAuth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">http_auth</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sparql_wrapper</span>

<div class="viewcode-block" id="RemoteEndpoint.peel"><a class="viewcode-back" href="../api.html#gastrodon.RemoteEndpoint.peel">[docs]</a>    <span class="k">def</span> <span class="nf">peel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copies part of a graph starting at node,  copying all facts linked at that</span>
<span class="sd">        node and continuing this transversal for each blank node that we find.</span>

<span class="sd">        :param node: URIRef starting point</span>
<span class="sd">        :return: Graph object containing copied graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peel</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">nodes</span><span class="o">=</span><span class="n">all_uri</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="n">used_ns</span> <span class="o">=</span> <span class="p">{</span><span class="n">URIRef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ns_part</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nodes</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">)}</span>
        <span class="n">ns_decl</span> <span class="o">=</span> <span class="p">[</span><span class="n">ns</span> <span class="k">for</span> <span class="n">ns</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefixes</span><span class="o">.</span><span class="n">namespaces</span><span class="p">()</span> <span class="k">if</span> <span class="n">ns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">used_ns</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ns_decl</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">namespace_manager</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

    <span class="k">def</span> <span class="nf">_peel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
        <span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            SELECT (?that as ?s) ?p ?o {</span>
<span class="s2">                ?that ?p ?o .</span>
<span class="s2">            }</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">bindings</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;that&quot;</span><span class="p">:</span> <span class="n">node</span><span class="p">})</span>
        <span class="n">bnodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">urins</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">items</span><span class="p">[</span><span class="s2">&quot;results&quot;</span><span class="p">][</span><span class="s2">&quot;bindings&quot;</span><span class="p">]:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsonToNode</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">])</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsonToNode</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">])</span>
                <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsonToNode</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">URIRef</span><span class="p">):</span>
                    <span class="n">urins</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ns_part</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">URIRef</span><span class="p">):</span>
                    <span class="n">urins</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ns_part</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">URIRef</span><span class="p">):</span>
                    <span class="n">urins</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ns_part</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>

                <span class="n">output</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">BNode</span><span class="p">)</span> <span class="ow">and</span> <span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bnodes</span><span class="p">:</span>
                    <span class="n">bnodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">output</span>

            <span class="c1"># note that the detailed behavior of blank nodes tends to be different in different triple stores,</span>
            <span class="c1"># in particular,  although almost all triple stores have some way to refer to a blank node inside the</span>
            <span class="c1"># triple store,  there is no standard way to do this.</span>
            <span class="c1">#</span>
            <span class="c1"># This works with Virtuoso but I tried a number of things that don&#39;t work (such as putting a list of</span>
            <span class="c1"># nodeId&#39;s in the form &lt;nodeID://b506362&gt; in an IN clause in a FILTER statement) or things that work but</span>
            <span class="c1"># are too slow (filtering on STR(?s))</span>

            <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span><span class="p">(</span><span class="n">query</span><span class="p">,</span><span class="n">bindings</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;that&quot;</span><span class="p">:</span><span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()})</span>

    <span class="k">def</span> <span class="nf">_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparql</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SPARQLResult</span><span class="p">:</span>
        <span class="n">that</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapper</span><span class="p">()</span>
        <span class="n">that</span><span class="o">.</span><span class="n">setQuery</span><span class="p">(</span><span class="n">sparql</span><span class="p">)</span>
        <span class="n">that</span><span class="o">.</span><span class="n">setReturnFormat</span><span class="p">(</span><span class="n">JSON</span><span class="p">)</span>
        <span class="n">json_result</span><span class="o">=</span><span class="n">that</span><span class="o">.</span><span class="n">queryAndConvert</span><span class="p">()</span>
        <span class="n">res</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;type_&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;SELECT&quot;</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;vars_&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Variable</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">json_result</span><span class="p">[</span><span class="s2">&quot;head&quot;</span><span class="p">][</span><span class="s2">&quot;vars&quot;</span><span class="p">]]</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">bindings</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">json_row</span> <span class="ow">in</span> <span class="n">json_result</span><span class="p">[</span><span class="s2">&quot;results&quot;</span><span class="p">][</span><span class="s2">&quot;bindings&quot;</span><span class="p">]:</span>
            <span class="n">rdf_row</span><span class="o">=</span><span class="p">{}</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;vars_&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="ow">in</span> <span class="n">json_row</span><span class="p">:</span>
                    <span class="n">rdf_row</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_jsonToNode</span><span class="p">(</span><span class="n">json_row</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">variable</span><span class="p">)])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rdf_row</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
            <span class="n">bindings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rdf_row</span><span class="p">)</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;bindings&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">bindings</span>
        <span class="k">return</span> <span class="n">SPARQLResult</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparql</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="n">result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_select</span><span class="p">(</span><span class="n">sparql</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">S</span><span class="o">=</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="n">P</span><span class="o">=</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
        <span class="n">O</span><span class="o">=</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;o&quot;</span><span class="p">)</span>
        <span class="n">neo</span><span class="o">=</span><span class="n">Graph</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fact</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">bindings</span><span class="p">:</span>
            <span class="n">neo</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">fact</span><span class="p">[</span><span class="n">S</span><span class="p">],</span><span class="n">fact</span><span class="p">[</span><span class="n">P</span><span class="p">],</span><span class="n">fact</span><span class="p">[</span><span class="n">O</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">neo</span></div>


<div class="viewcode-block" id="LocalEndpoint"><a class="viewcode-back" href="../api.html#gastrodon.LocalEndpoint">[docs]</a><span class="k">class</span> <span class="nc">LocalEndpoint</span><span class="p">(</span><span class="n">Endpoint</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        LocalEndpoint for doing queries against a local RDFLib graph.</span>

<span class="sd">        :param graph: Graph object that will be encapsulated</span>
<span class="sd">        :param prefixes: Graph defining prefixes for this Endpoint,  will be the same as the input graph by default</span>
<span class="sd">        :param base_uri: base_uri for resolving URLs</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">graph</span><span class="p">:</span><span class="n">Graph</span><span class="p">,</span><span class="n">prefixes</span><span class="p">:</span><span class="n">Graph</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">prefixes</span><span class="p">:</span>
            <span class="n">prefixes</span><span class="o">=</span><span class="n">graph</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">prefixes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span>

    <span class="k">def</span> <span class="nf">_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparql</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SPARQLResult</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">sparql</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparql</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Graph</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">sparql</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparql</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span><span class="kc">None</span> <span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sparql</span><span class="p">)</span>
        <span class="k">return</span></div>

<span class="k">def</span> <span class="nf">_toRDF</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">lex</span><span class="p">,</span><span class="n">datatype</span><span class="o">=</span><span class="n">_castPythonToLiteral</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span><span class="n">datatype</span><span class="o">=</span><span class="n">datatype</span><span class="p">)</span>

<div class="viewcode-block" id="ttl"><a class="viewcode-back" href="../api.html#gastrodon.ttl">[docs]</a><span class="k">def</span> <span class="nf">ttl</span><span class="p">(</span><span class="n">g</span><span class="p">:</span><span class="n">Store</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Write out Graph (or other Store) in Turtle format to stdout.</span>

<span class="sd">    :param g: input Graph</span>
<span class="sd">    :return: nothing</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">TurtleSerializer</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span><span class="n">spacious</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="all_uri"><a class="viewcode-back" href="../api.html#gastrodon.all_uri">[docs]</a><span class="k">def</span> <span class="nf">all_uri</span><span class="p">(</span><span class="n">g</span><span class="p">:</span><span class="n">Graph</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns the set of all URIRef objects inside Graph g appearing in the</span>
<span class="sd">    subject. predicate, or object position in any triple.</span>

<span class="sd">    :param g:  input Graph</span>
<span class="sd">    :return: a set of URIRef objects for all URIRefs that appear in this graph</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">uris</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">fact</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">triples</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">fact</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">URIRef</span><span class="p">):</span>
                <span class="n">uris</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">uris</span></div>

<div class="viewcode-block" id="show_image"><a class="viewcode-back" href="../api.html#gastrodon.show_image">[docs]</a><span class="k">def</span> <span class="nf">show_image</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Embed a PNG image with a filename relative to the current working directory into an</span>
<span class="sd">    IPython/Jupyter notebook.</span>

<span class="sd">    :param filename:</span>
<span class="sd">    :return: nothing</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">display_png</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="inline"><a class="viewcode-back" href="../api.html#gastrodon.inline">[docs]</a><span class="k">def</span> <span class="nf">inline</span><span class="p">(</span><span class="n">turtle</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Convert turtle-format RDF into a Graph</span>

<span class="sd">    :param turtle: str in Turtle Format</span>
<span class="sd">    :return: Graph with corresponding triples</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">g</span><span class="o">=</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">g</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">turtle</span><span class="p">,</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;ttl&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LocalEndpoint</span><span class="p">(</span><span class="n">g</span><span class="p">)</span></div>

<div class="viewcode-block" id="one"><a class="viewcode-back" href="../api.html#gastrodon.one">[docs]</a><span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    In cases where a composite object has only a single element,  returns the element.</span>

<span class="sd">    Element types currently supported are:</span>

<span class="sd">    DataFrame</span>
<span class="sd">        returns single element of a single row</span>
<span class="sd">    List (or object castable to list)</span>
<span class="sd">        returns only element of list</span>

<span class="sd">    :param items: a composite object</span>
<span class="sd">    :return: only member of composite object,  otherwise throw exception</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">items</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">items</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;one(x) requires that DataFrame x have exactly one row and one column&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">items</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">l</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Result has more than one member&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Cannot get first member from empty container&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="member"><a class="viewcode-back" href="../api.html#gastrodon.member">[docs]</a><span class="k">def</span> <span class="nf">member</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return URIRef that (as ?predicate) states that ?object is the index(th) member of</span>
<span class="sd">    ?subject.</span>

<span class="sd">    :param index: non-negative integer index:</span>
<span class="sd">    :return: URIRef rdf:_N for N=index+1</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">URIRef</span><span class="p">(</span><span class="s2">&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#_</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span></div>

<span class="k">def</span> <span class="nf">_extract_decl</span><span class="p">(</span><span class="n">parsed</span><span class="p">:</span> <span class="n">ParseResults</span><span class="p">,</span><span class="n">parseFn</span><span class="p">):</span>
    <span class="n">ns</span><span class="o">=</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">base_iri</span><span class="o">=</span><span class="kc">None</span>
    <span class="k">for</span> <span class="n">decl</span> <span class="ow">in</span> <span class="n">parsed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">parseFn</span><span class="o">==</span><span class="n">_parseQuery</span> <span class="k">else</span> <span class="n">parsed</span><span class="p">[</span><span class="s2">&quot;prologue&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">if</span> <span class="s1">&#39;prefix&#39;</span> <span class="ow">in</span> <span class="n">decl</span><span class="p">:</span>
            <span class="n">ns</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">decl</span><span class="p">[</span><span class="s2">&quot;prefix&quot;</span><span class="p">],</span><span class="n">decl</span><span class="p">[</span><span class="s2">&quot;iri&quot;</span><span class="p">],</span><span class="n">override</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s1">&#39;iri&#39;</span> <span class="ow">in</span> <span class="n">decl</span><span class="p">:</span>
            <span class="n">base_iri</span><span class="o">=</span><span class="n">decl</span><span class="p">[</span><span class="s2">&quot;iri&quot;</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">base_iri</span><span class="p">,</span><span class="n">ns</span><span class="p">)</span>

<span class="nd">@lru_cache</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">_parseUpdate</span><span class="p">(</span><span class="n">sparql</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">parseUpdate</span><span class="p">(</span><span class="n">sparql</span><span class="p">)</span>

<span class="nd">@lru_cache</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">_parseQuery</span><span class="p">(</span><span class="n">sparql</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">parseQuery</span><span class="p">(</span><span class="n">sparql</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_extract_group_by</span><span class="p">(</span><span class="n">parsed</span><span class="p">):</span>
    <span class="n">main_part</span><span class="o">=</span><span class="n">parsed</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="s1">&#39;groupby&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">main_part</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="n">Variable</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">main_part</span><span class="p">[</span><span class="s1">&#39;groupby&#39;</span><span class="p">][</span><span class="s1">&#39;condition&#39;</span><span class="p">]]):</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">return</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">main_part</span><span class="p">[</span><span class="s1">&#39;groupby&#39;</span><span class="p">][</span><span class="s1">&#39;condition&#39;</span><span class="p">]]</span>

</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Paul A. Houle.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.9.3',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>